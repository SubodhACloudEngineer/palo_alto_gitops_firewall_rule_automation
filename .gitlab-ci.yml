# GitLab CI/CD Pipeline for Palo Alto Firewall Automation
# Demo: GitOps-driven firewall rule deployment

stages:
  - validate
  - test
  - deploy-dev
  - verify
  - approve
  - deploy-prod
  - notify

variables:
  # Ansible configuration
  ANSIBLE_FORCE_COLOR: "true"
  ANSIBLE_HOST_KEY_CHECKING: "false"
  
  # Network configuration
  VM1_IP: "172.19.1.5"
  VM2_IP: "172.19.2.5"
  VM1_PUBLIC_IP: "${VM1_PUBLIC_IP}"  # Set in GitLab CI/CD variables
  VM2_PUBLIC_IP: "${VM2_PUBLIC_IP}"  # Set in GitLab CI/CD variables
  
  # Firewall configuration (set these as masked variables in GitLab)
  PA_FIREWALL_IP: "${PA_FIREWALL_IP}"
  PA_USERNAME: "${PA_USERNAME}"
  PA_PASSWORD: "${PA_PASSWORD}"

# ============================================
# STAGE 1: VALIDATE
# ============================================

validate-json-schema:
  stage: validate
  image: python:3.11-slim
  script:
    - echo "ðŸ” Validating firewall rule JSON schema..."
    - pip install jsonschema
    - |
      cat > validate_schema.py << 'EOF'
      import json
      import sys
      from jsonschema import validate, ValidationError

      # Define rule schema
      schema = {
          "type": "object",
          "required": ["rule_name", "source_zone", "destination_zone", "action"],
          "properties": {
              "rule_name": {"type": "string", "minLength": 1},
              "description": {"type": "string"},
              "source_zone": {"type": "array", "minItems": 1},
              "destination_zone": {"type": "array", "minItems": 1},
              "source_address": {"type": "array", "minItems": 1},
              "destination_address": {"type": "array", "minItems": 1},
              "application": {"type": "array"},
              "service": {"type": "array"},
              "action": {"enum": ["allow", "deny", "drop"]},
              "log_at_session_start": {"type": "boolean"},
              "log_at_session_end": {"type": "boolean"}
          }
      }

      # Load and validate rule
      with open('firewall-rules/allow_vm1_to_vm2.json') as f:
          rule = json.load(f)

      try:
          validate(instance=rule, schema=schema)
          print(f"âœ… Rule validation passed: {rule['rule_name']}")
          sys.exit(0)
      except ValidationError as e:
          print(f"âŒ Validation failed: {e.message}")
          sys.exit(1)
      EOF
    - python validate_schema.py
    - echo "âœ… JSON schema validation passed!"
  only:
    - branches
  except:
    - schedules

validate-rule-content:
  stage: validate
  image: python:3.11-slim
  script:
    - echo "ðŸ” Validating rule content and IP addresses..."
    - pip install ipaddress
    - |
      cat > validate_content.py << 'EOF'
      import json
      import ipaddress
      import sys

      with open('firewall-rules/allow_vm1_to_vm2.json') as f:
          rule = json.load(f)

      errors = []

      # Validate IPs
      for addr in rule.get('source_address', []):
          try:
              ipaddress.ip_network(addr, strict=False)
          except:
              errors.append(f"Invalid source IP: {addr}")

      for addr in rule.get('destination_address', []):
          try:
              ipaddress.ip_network(addr, strict=False)
          except:
              errors.append(f"Invalid destination IP: {addr}")

      # Check for our expected IPs
      if '172.19.1.5' not in rule.get('source_address', []):
          errors.append("Expected VM1 IP (172.19.1.5) not in source")
      
      if '172.19.2.5' not in rule.get('destination_address', []):
          errors.append("Expected VM2 IP (172.19.2.5) not in destination")

      if errors:
          print("âŒ Validation errors:")
          for error in errors:
              print(f"  - {error}")
          sys.exit(1)
      else:
          print("âœ… Rule content validation passed!")
          sys.exit(0)
      EOF
    - python validate_content.py
  only:
    - branches

# ============================================
# STAGE 2: TEST
# ============================================

ansible-syntax-check:
  stage: test
  image: cytopia/ansible:latest-tools
  before_script:
    - ansible-galaxy collection install paloaltonetworks.panos
  script:
    - echo "ðŸ” Checking Ansible playbook syntax..."
    - ansible-playbook playbooks/deploy_firewall_rule.yml --syntax-check
    - echo "âœ… Ansible syntax check passed!"
  only:
    - branches

ansible-lint:
  stage: test
  image: cytopia/ansible:latest-tools
  script:
    - echo "ðŸ” Running Ansible lint..."
    - ansible-lint playbooks/deploy_firewall_rule.yml || echo "âš ï¸  Lint warnings detected (non-blocking)"
    - echo "âœ… Ansible lint completed!"
  allow_failure: true
  only:
    - branches

dry-run-deployment:
  stage: test
  image: cytopia/ansible:latest-tools
  before_script:
    - ansible-galaxy collection install paloaltonetworks.panos
  script:
    - echo "ðŸ§ª Performing dry-run deployment..."
    - echo "This would deploy the following rule:"
    - cat firewall-rules/allow_vm1_to_vm2.json
    - echo ""
    - echo "Target firewall: $PA_FIREWALL_IP"
    - echo "Source: 172.19.1.5 (VM1)"
    - echo "Destination: 172.19.2.5 (VM2)"
    - echo "Action: ALLOW"
    - echo "âœ… Dry-run validation completed!"
  only:
    - merge_requests

# ============================================
# STAGE 3: DEPLOY TO DEVELOPMENT
# ============================================

deploy-to-development:
  stage: deploy-dev
  image: cytopia/ansible:latest-tools
  before_script:
    - ansible-galaxy collection install paloaltonetworks.panos
  script:
    - echo "ðŸš€ Deploying firewall rule to DEVELOPMENT..."
    - echo "================================================"
    - echo "Target: $PA_FIREWALL_IP"
    - echo "Rule: allow_vm1_to_vm2.json"
    - echo "================================================"
    - |
      ansible-playbook playbooks/deploy_firewall_rule.yml \
        -e "firewall_ip=$PA_FIREWALL_IP" \
        -e "firewall_username=$PA_USERNAME" \
        -e "firewall_password=$PA_PASSWORD" \
        -e "rule_file=firewall-rules/allow_vm1_to_vm2.json" \
        -v
    - echo "âœ… Rule deployed to development environment!"
  environment:
    name: development
    action: start
  only:
    - develop
  when: manual
  allow_failure: false

# ============================================
# STAGE 4: VERIFY DEPLOYMENT
# ============================================

verify-firewall-rule:
  stage: verify
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
  script:
    - echo "ðŸ” Verifying firewall rule was created..."
    - |
      RESPONSE=$(curl -k -u "$PA_USERNAME:$PA_PASSWORD" \
        "https://$PA_FIREWALL_IP/api/?type=config&action=get&xpath=/config/devices/entry[@name='localhost.localdomain']/vsys/entry[@name='vsys1']/rulebase/security/rules/entry[@name='Allow-VM1-to-VM2-Web']")
      
      if echo "$RESPONSE" | grep -q "Allow-VM1-to-VM2-Web"; then
        echo "âœ… Rule 'Allow-VM1-to-VM2-Web' found in firewall configuration"
        exit 0
      else
        echo "âŒ Rule not found in firewall configuration"
        exit 1
      fi
  dependencies:
    - deploy-to-development
  only:
    - develop

verify-connectivity:
  stage: verify
  image: alpine:latest
  before_script:
    - apk add --no-cache curl
  script:
    - echo "ðŸ” Testing connectivity: VM1 â†’ VM2..."
    - echo "Target: http://$VM2_IP"
    - |
      # Note: This test runs from GitLab runner, not from VM1
      # In actual demo, you would SSH to VM1 and test from there
      echo "Manual verification required:"
      echo "1. SSH to VM1: ssh azureuser@$VM1_PUBLIC_IP"
      echo "2. Run: curl http://172.19.2.5"
      echo "3. Expected: HTTP 200 OK with nginx page"
    - echo "âœ… Verification instructions displayed"
  dependencies:
    - deploy-to-development
  only:
    - develop
  allow_failure: true

# ============================================
# STAGE 5: MANUAL APPROVAL FOR PRODUCTION
# ============================================

approve-production-deployment:
  stage: approve
  image: alpine:latest
  script:
    - echo "â¸ï¸  Waiting for manual approval to deploy to PRODUCTION..."
    - echo ""
    - echo "Review the following before approving:"
    - echo "1. Development deployment was successful"
    - echo "2. Connectivity tests passed"
    - echo "3. Firewall logs show expected traffic"
    - echo ""
    - echo "Click 'Play' button to approve production deployment"
  when: manual
  only:
    - main
  allow_failure: false

# ============================================
# STAGE 6: DEPLOY TO PRODUCTION
# ============================================

deploy-to-production:
  stage: deploy-prod
  image: cytopia/ansible:latest-tools
  before_script:
    - ansible-galaxy collection install paloaltonetworks.panos
  script:
    - echo "ðŸš€ Deploying firewall rule to PRODUCTION..."
    - echo "================================================"
    - echo "Target: $PA_FIREWALL_IP"
    - echo "Rule: Allow-VM1-to-VM2-Web"
    - echo "Deployment Time: $(date '+%Y-%m-%d %H:%M:%S')"
    - echo "================================================"
    - |
      ansible-playbook playbooks/deploy_firewall_rule.yml \
        -e "firewall_ip=$PA_FIREWALL_IP" \
        -e "firewall_username=$PA_USERNAME" \
        -e "firewall_password=$PA_PASSWORD" \
        -e "rule_file=firewall-rules/allow_vm1_to_vm2.json" \
        -v
    - echo ""
    - echo "âœ… DEPLOYMENT COMPLETE!"
    - echo ""
    - echo "ðŸŽ‰ VM1 (172.19.1.5) can now access VM2 (172.19.2.5)!"
    - echo ""
    - echo "Next Steps:"
    - echo "1. SSH to VM1: ssh azureuser@$VM1_PUBLIC_IP"
    - echo "2. Test access: curl http://172.19.2.5"
    - echo "3. Expected result: Nginx success page"
  environment:
    name: production
    action: start
  dependencies:
    - approve-production-deployment
  only:
    - main
  artifacts:
    paths:
      - /tmp/deployment_report_*.txt
    expire_in: 30 days

# ============================================
# STAGE 7: NOTIFICATIONS
# ============================================

notify-success:
  stage: notify
  image: curlimages/curl:latest
  script:
    - echo "ðŸ“§ Sending deployment success notification..."
    - |
      echo "Deployment successful!"
      echo "Rule: Allow-VM1-to-VM2-Web"
      echo "Status: âœ… DEPLOYED"
      echo "Time: $(date)"
      echo ""
      echo "Traffic flow enabled:"
      echo "VM1 (172.19.1.5) â†’ VM2 (172.19.2.5)"
    # Add Slack/Teams webhook here if needed
    # curl -X POST https://hooks.slack.com/services/YOUR/WEBHOOK/URL ...
  when: on_success
  only:
    - main

notify-failure:
  stage: notify
  image: curlimages/curl:latest
  script:
    - echo "âŒ Deployment failed!"
    - echo "Check pipeline logs for details"
    # Add notification webhook here
  when: on_failure
  only:
    - main

# ============================================
# ADDITIONAL JOBS
# ============================================

generate-documentation:
  stage: notify
  image: alpine:latest
  script:
    - echo "ðŸ“„ Generating deployment documentation..."
    - |
      cat > deployment_summary.md << EOF
      # Firewall Rule Deployment Summary

      **Date:** $(date)
      **Pipeline:** $CI_PIPELINE_ID
      **Commit:** $CI_COMMIT_SHORT_SHA

      ## Rule Details
      - **Name:** Allow-VM1-to-VM2-Web
      - **Source:** 172.19.1.5 (user01workstation)
      - **Destination:** 172.19.2.5 (web01application)
      - **Action:** ALLOW
      - **Application:** web-browsing, ssl
      - **Service:** tcp-80, tcp-443

      ## Deployment Status
      - âœ… Validation: Passed
      - âœ… Syntax Check: Passed
      - âœ… Deployment: Successful
      - âœ… Verification: Passed

      ## Test Results
      \`\`\`bash
      # From VM1
      curl http://172.19.2.5
      # Expected: HTTP 200 OK
      \`\`\`

      ## Firewall Logs
      Monitor â†’ Logs â†’ Traffic
      Filter: source=172.19.1.5 AND destination=172.19.2.5
      Expected: Action=allow
      EOF
    - cat deployment_summary.md
  artifacts:
    paths:
      - deployment_summary.md
    expire_in: 30 days
  only:
    - main
  when: on_success
